analytic

# Phong
# normalization constant:
# 1/Integrate[Cos[x]^n Cos[x] Sin[x], {x, 0, Pi/2}, {phi, 0, 2 Pi} , Assumptions -> n > 0]
# == (2 + n)/(2 Pi)

# variables go here...
# only floats supported right now.
# [type] [name] [min val] [max val] [default val]

::begin parameters
float n 1 1000 100
bool normalized 1
::end parameters

# Then comes the shader. This should be GLSL code
# that defines a function called BRDF (although you can
# add whatever else you want too, like sqr() below).

::begin shader

// reflect() is built into OpenGL ES and as a result the below won't compile.

/*
 *vec3 reflect(vec3 I, vec3 N)
 *{
 *    return 2*dot(I,N)*N - I;
 *}
 */

//Disney uses different convention than OpenGL ES does,
//assumes incoming ray comes in the opposite direction
vec3 refl_ray(vec3 I, vec3 N)
{
  return reflect(-I,N);
}

const float PI = 3.14159265358979323846;

vec3 BRDF( vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y )
{
    //vec3 R = reflect(L,N);
    vec3 R = refl_ray(L,N);
    float D = pow(max(0.0, dot(R,V)),n);
    if (normalized)
        D *= (2.0+n) / (2.0*PI);
    return vec3(D);
}

::end shader
