analytic

# Ashikhmin Shirley 2000 - Anisotropic phong reflectance model

# variables go here...
# only floats supported right now.
# [type] [name] [min val] [max val] [default val]

::begin parameters
float Rs 0 1 .1
float Rd 0 1 1
float nu 1 1000 100
float nv 1 1000 100
bool isotropic 1
bool coupled_diffuse 1
::end parameters


# Then comes the shader. This should be GLSL code
# that defines a function called BRDF (although you can
# add whatever else you want too, like sqr() below).

::begin shader

float sqr( float x )
{
    return x*x;
}

float Fresnel(float f0, float u)
{
    // from Schlick
    return f0 + (1.0-f0) * pow(1.0-u, 5.0);
}

vec3 BRDF( vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y )
{
    float PI = 3.14159265358979323846;
    vec3 H = normalize(L+V);
    float HdotV = dot(H,V);
    float HdotX = dot(H,X);
    float HdotY = dot(H,Y);
    float NdotH = dot(N,H);
    float NdotV = dot(N,V);
    float NdotL = dot(N,L);

    //bool isotropic = false;

    float F = Fresnel(Rs, HdotV);
    //float norm_s = sqrt((nu+1.0)*((isotropic?nu:nv)+1.0))/(8.0*PI);
    //float n = isotropic ? nu :(nu*sqr(HdotX) + nv*sqr(HdotY))/(1.0-sqr(NdotH));
    float norm_s;
    float n;
    if(isotropic){
      norm_s = sqrt((nu+1.0)*((nu)+1.0))/(8.0*PI);
      n = nu;
    } else {
      norm_s = sqrt((nu+1.0)*((nv)+1.0))/(8.0*PI);
      n = (nu*sqr(HdotX) + nv*sqr(HdotY))/(1.0-sqr(NdotH));
    }

    float rho_s = norm_s * F * pow(max(NdotH,0.0), n) / (HdotV * max(NdotV, NdotL));

    float rho_d = 28.0/(23.0*PI) * Rd * (1.0-pow(1.0-NdotV/2.0, 5.0)) * (1.0-pow(1.0-NdotL/2.0, 5.0));
    if (coupled_diffuse) rho_d *= (1.0-Rs);

    return vec3(rho_s + rho_d);
}

::end shader
